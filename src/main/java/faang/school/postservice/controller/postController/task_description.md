# Система постов

## Описание

Как пользователь, я хочу иметь возможность писать текстовые посты для того, чтобы делиться своими мыслями,
знаниями и информацией с другими пользователями.

## Условия задачи

Пользователи приложения могут писать ПОКА ТОЛЬКО ТЕКСТОВЫЕ посты как, например, на LinkedIn.
Из этих постов затем будет формироваться лента новостей для подписчиков. По сути это просто некоторый текстовый блок
с любой информацией, которую пользователь хочет разместить в своём профиле.

Позднее посты можно будет лайкать и оставлять под ними комментарии, но это делается в рамках других задач.

В этой задаче нам нужно разработать систему управления постами пользователя или проекта

Любой пост может быть опубликован под авторством либо пользователя, либо целого проекта, но не обоих сразу.
Обязательно должно быть что-то из двух вариантов.

По умолчанию пост создаётся в состоянии черновика, а затем отдельным действием его можно опубликовать.

Т.о. формируется набор следующих доступных действий для системы управления постами:

1. **Создание черновика поста.** Ровно один автор. Автором может быть либо пользователь, либо проект.
   Наполнение поста не может быть пустым. Автор должен быть существующим в системе пользователем или проектом.

2. **Публикация поста.** Опубликовать можно любой существующий пост. Нельзя ещё раз опубликовать пост,
   который уже был опубликован ранее. Запомнить дату публикации.

3. **Обновление поста** (например, можно изменить текст). Нельзя изменить автора поста. Нельзя удалить автора поста.

4. **Мягкое удаление поста по id**. Не удаляем из БД, а помечаем, как удаленный и продолжаем хранить.

5. **Получение поста по id.**

6. **Получение всех черновиков** не удаленных постов за авторством **пользователя с данным id.**
   Посты должны быть отсортированы по дате создания от новых к старым.

7. **Получение всех черновиков** не удаленных постов за авторством **проекта с данным id.**
   Посты должны быть отсортированы по дате создания от новых к старым.

8. **Получение всех опубликованных** не удаленных постов за авторством **пользователя с данным id.**
   Посты должны быть отсортированы по дате публикации от новых к старым.

9. **Получение всех опубликованных** не удаленных постов за авторством **проекта с данным id.**
   Посты должны быть отсортированы по дате публикации от новых к старым.

## Тех. детали

Всё делаем в сервисе `post_service` (отдельный Java проект).

Под каждый пункт ниже создать метод в классе `PostController`. Провести необходимую валидацию принимаемых в эти методы
данных, если необходимо. Контроллер принимает и возвращает только объекты `PostDto` или коллекции этих объектов.
Нужно создать класс `PostDto` с минимальным необходимым набором полей для обеспечения работы функционала.
Какие это вообще могут быть поля, можно посмотреть в классе `Post`, который уже заранее создан.

Все методы контроллера должны быть помечены соответствующими аннотациями для создания эндпоинтов:

* `@GetMapping`,
* `@PostMapping`,
* `@PutMapping`, а пути в них также должны быть сделаны по **REST**.

Далее из этих методов уже вызывать соответствующие методы класса **PostService**, которые выполняют всю бизнес-логику
необходимую для того или иного действия. В каждом из этих методов также не забыть провести основную ЛОГИЧЕСКУЮ
валидацию.
Например, класс-контроллер валидирует то, что пост создаётся с каким-то не пустым сообщением.
А сервис же проверит более сложные сценарии, например, что у поста автором может быть либо пользователь, либо проект,
но не оба вместе или вообще никто.

Далее в **PostService** используются методы **PostRepository** для непосредственного взаимодействия с БД.
Эти методы уже готовы. Подробнее про каждый ниже. **PostService** также принимает и возвращает только объекты **PostDto
**.
Но внутри своих методов может работать с заранее доступной сущностью **Post**. Она уже есть в проекте.
Используйте **MapStruct** библиотеку для удобного преобразования **PostDto** в **Post** и наоборот.

Все классы c логикой должны быть _Spring beans_. И для создания бинов на основе этих классов должны использоваться
корректные аннотации, соответствующие названиям и ролям этих классов — **@RestController** и **@Service**
соответственно.

Везде помним про маппинг из **dto** в сущности для БД и наоборот! Максимально используем **lombok** для всего!
Все зависимости между _Spring bean_ должны быть проложены с помощью **autowiring**.

Для всех классов с логикой должны быть написаны _unit_-тесты, покрывающие всех их публичные методы.
Для этого используем **JUnit** и **Mockito**.

## Подробности использования готовых компонентов

Если вы не знакомы с логикой работы с БД (пройдём позже на буткемпе) и не готовы разбираться с ней самостоятельно прямо
сейчас,
то в проекте уже заранее создан интерфейс `PostRepository` со всеми методами, которые могут вам пригодиться в процессе
реализации этого функционала

Вот эти методы:

* `save(Post post)` — сохраняет данный объект поста в базу данных или обновляет уже имеющийся пост в базе данных,
  `id` которого совпадает с `id` переданного объекта в этот метод;

* `findById(long id)` — возвращает `Optional<Post>`. Находит в базе данных строку с постом с переданным в метод `id`.
  Возвращает `Optional` потому, что в БД может и не оказаться строки с таким `id`, если мы ищем несуществующий пост;

* `findByAuthorId(long authorId)` — возвращает все посты в БД, у которых автором является пользователь с `id`,
  совпадающим с `authorId`, переданным в метод;

* `findByProjectId(long projectId)` — возвращает все посты в БД, у которых автором является проект с `id`, совпадающим
  с `projectId`, переданным в метод.

Также поскольку пользователь и проект хранятся в других микросервисах, а не в `post_service` (юзер — в `user_service`,
а проект в `project_service`), то мы создали два _Spring_ бина, которые умеют в них обращаться по Интернету:
`UserServiceClient` умеет обращаться в `user_service`, а `ProjectServiceClient` в `project_service` соответственно.

В `UserServiceClient`: `getUser(long id)` возвращает пользователя с данным `id` из `user_service`.
Бросит исключение `FeignException`, если такого пользователя нет в `user_service`.

В `ProjectServiceClient`: `getProject(long id)` возвращает проект с данным `id` из `project_service`.
Бросит исключение `FeignException`, если такого проекта нет в `project_service`.

Эти методы можно использовать для валидации присутствия пользователя и проекта в системе.